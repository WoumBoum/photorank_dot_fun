{% extends "base.html" %}

{% block content %}
<div class="container" data-init-app>
    <header>
        <h1>Leaderboard</h1>
        <nav>
            <a href="/">Vote</a>
            <a href="/upload">Upload</a>
            <a href="/stats">Stats</a>
            <a href="/categories">Categories</a>
            <a href="/login" id="auth-link">Login</a>
            <button class="theme-toggle" id="theme-toggle" title="Toggle dark mode">‚óê</button>
        </nav>
    </header>

    <div class="leaderboard">
        <h2 id="category-question">Results of:</h2>
        <div id="category-vote-count" style="margin-top:6px;color:#666;font-size:0.95em;"></div>
        <div style="text-align:center;margin:10px 0 20px 0;">
            <button id="download-leaderboard" class="btn" style="padding:6px 12px;">üì∏ Screen current leaderboard</button>
        </div>
        <div class="current-category">
            {% if category_name %}
            <span>Category: <strong id="cat-name-display">{{ category_name }}</strong></span>
            <div id="cat-edit-controls" style="display:none;margin-top:6px;gap:8px;">
              <button id="edit-cat-name" class="btn" style="padding:4px 8px;">Edit name</button>
              <button id="edit-cat-question" class="btn" style="padding:4px 8px;">Edit question</button>
            </div>
            <a href="/categories" style="margin-left: 10px; font-size: 0.9em;">All Categories</a>
            <div class="category-meta-line" style="margin-top:4px;color:#666;font-size:0.95em;">
              <span class="brand">photorank.fun</span>
              <span class="divider" style="color:#ccc;">¬∑</span>
              <span class="tagline">disagree? cope harder or actually vote</span>
            </div>
            {% elif selected_category_name %}
            <span>Showing: <strong id="cat-name-display">{{ selected_category_name }}</strong></span>
            <div id="cat-edit-controls" style="display:none;margin-top:6px;gap:8px;">
              <button id="edit-cat-name" class="btn" style="padding:4px 8px;">Edit name</button>
              <button id="edit-cat-question" class="btn" style="padding:4px 8px;">Edit question</button>
            </div>
            <a href="/categories" style="margin-left: 10px; font-size: 0.9em;">Change Category</a>
            <div class="category-meta-line" style="margin-top:4px;color:#666;font-size:0.95em;">
              <span class="brand">photorank.fun</span>
              <span class="divider" style="color:#ccc;">¬∑</span>
              <span class="tagline">disagree? cope harder or actually vote</span>
            </div>
            {% else %}
            <span>No category selected</span>
            <a href="/categories" style="margin-left: 10px; font-size: 0.9em;">Select Category</a>
            {% endif %}
        </div>
        <div class="photo-grid" id="leaderboard-grid">
            <!-- Photos will be loaded here -->
        </div>
        <!-- Moderator-only boost panel -->
        <div id="boost-panel" style="display:none;margin-top:20px;border-top:1px solid #e0e0e0;padding-top:12px;">
            <div style="font-size:0.95em;margin-bottom:6px;color:#444;">Moderator tools</div>
            <label style="margin-right:8px;">Add fake votes:</label>
            <input type="number" id="boost-amount" value="100" style="width:120px;padding:6px;margin-right:8px;" />
            <button id="boost-apply" class="btn">Apply</button>
            <span id="boost-status" style="margin-left:10px;color:#666;"></span>
        </div>
    </div>
</div>

<script>
    async function isModerator(categoryName) {
        try {
            if (!categoryName) return false;
            const catRes = await fetch('/api/categories/select-by-name/' + encodeURIComponent(categoryName), { method: 'POST', credentials: 'include' });
            if (!catRes.ok) return false;
            const cat = await catRes.json();
            const details = await (await fetch('/api/categories/' + cat.category_id)).json();
            const token = localStorage.getItem('token');
            if (!token) return false;
            const meRes = await fetch('/api/users/me', { headers: { Authorization: 'Bearer ' + token } });
            if (!meRes.ok) return false;
            const me = await meRes.json();
            return !!(me && me.is_moderator);
        } catch (e) { return false; }
    }
    document.addEventListener('DOMContentLoaded', async function () {
        const categoryName = "{{ category_name or '' }}";

        if (categoryName) {
            setupBoostPanel(categoryName);
            try {
                const cat = await (await fetch('/api/categories/select-by-name/' + encodeURIComponent(categoryName), { method: 'POST', credentials: 'include' })).json();
                // Load category details for vote count
                try {
                    const detailsList = await (await fetch('/api/categories/details?t=' + Date.now())).json();
                    const det = detailsList.find(x => x.name === categoryName);
                    if (det && typeof det.total_votes !== 'undefined') {
                        const el = document.getElementById('category-vote-count');
                        if (el) el.textContent = `ranking based on ${det.total_votes} votes`;
                    }
                } catch (e) { /* ignore */ }
                const catData = await (await fetch('/api/categories/' + cat.category_id)).json();
                 if (catData && catData.question) document.getElementById('category-question').textContent = `Results of: ${catData.question}`;
                 // Setup edit controls visibility and actions
                 try {
                   const token = localStorage.getItem('token');
                   if (token) {
                     const meRes = await fetch('/api/users/me', { headers: { Authorization: 'Bearer ' + token } });
                     if (meRes.ok) {
                       const me = await meRes.json();
                       const detailsList = await (await fetch('/api/categories/details?t=' + Date.now())).json();
                       const det = detailsList.find(x => x.name === categoryName);
                       const isOwner = me && det && det.owner_id && me.id === det.owner_id;
                       const isModerator = me && me.is_moderator;
                       if (isOwner || isModerator) {
                         const ctrl = document.getElementById('cat-edit-controls');
                         if (ctrl) ctrl.style.display = 'flex';
                         const editNameBtn = document.getElementById('edit-cat-name');
                         const editQBtn = document.getElementById('edit-cat-question');
                         if (editNameBtn) editNameBtn.onclick = async () => {
                           const current = document.getElementById('cat-name-display')?.textContent || categoryName;
                           const input = prompt('New category name:', current);
                           if (!input || input.trim() === current) return;
                           const res = await fetch(`/api/categories/${cat.category_id}`, {
                             method: 'PATCH',
                             headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                             body: JSON.stringify({ name: input.trim() })
                           });
                           const data = await res.json().catch(()=>({detail:'Failed'}));
                           if (!res.ok) { alert(data.detail || 'Failed'); return; }
                           document.getElementById('cat-name-display').textContent = data.name;
                           location.reload();
                         };
                         if (editQBtn) editQBtn.onclick = async () => {
                           const currentQ = (catData && catData.question) || '';
                           const input = prompt('New question:', currentQ);
                           if (input === null) return;
                           const trimmed = input.trim();
                           if (!trimmed || trimmed === currentQ) return;
                           const res = await fetch(`/api/categories/${cat.category_id}`, {
                             method: 'PATCH',
                             headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
                             body: JSON.stringify({ question: trimmed })
                           });
                           const data = await res.json().catch(()=>({detail:'Failed'}));
                           if (!res.ok) { alert(data.detail || 'Failed'); return; }
                           document.getElementById('category-question').textContent = `Results of: ${data.question}`;
                         };
                       }
                     }
                   }
                 } catch (e) { /* ignore */ }
            } catch (e) { console.error('failed to fetch category question', e); }
            // Ensure session uses this category
            try {
                await fetch(`/api/categories/select-by-name/${encodeURIComponent(categoryName)}`, {
                    method: 'POST',
                    credentials: 'include'
                });
            } catch (e) { console.error('select-by-name failed', e); }

            // Rewrite top nav links to category-prefixed paths
            const nav = document.querySelector('header nav');
            if (nav) {
                const links = Array.from(nav.querySelectorAll('a'));
                const relink = (text, leaf) => {
                    const a = links.find(x => x.textContent.trim() === text);
                    if (a) a.href = `/${encodeURIComponent(categoryName)}/${leaf}`;
                };
                relink('Vote', 'vote');
                relink('Upload', 'upload');
                relink('Leaderboard', 'leaderboard');
            }

            // After category is set in session, load data using by-name endpoint
            await loadLeaderboard(categoryName);
        } else {
            // No category specified, load global leaderboard
            await loadLeaderboard(null);
        }
    });

    async function setupBoostPanel(categoryName) {
        const can = await isModerator(categoryName);
        const panel = document.getElementById('boost-panel');
        if (!panel) return;
        if (!can) { panel.style.display = 'none'; return; }
        panel.style.display = 'block';
        const btn = document.getElementById('boost-apply');
        const amt = document.getElementById('boost-amount');
        const status = document.getElementById('boost-status');
        btn.onclick = async () => {
            const n = parseInt(amt.value, 10) || 0;
            if (n === 0) { status.textContent = 'enter a non-zero number'; return; }
            try {
                const catSel = await (await fetch('/api/categories/select-by-name/' + encodeURIComponent(categoryName), { method: 'POST', credentials: 'include' })).json();
                const token = localStorage.getItem('token');
                const res = await fetch(`/api/categories/${catSel.category_id}/boost-votes?amount=${encodeURIComponent(n)}`, { method: 'POST', headers: { Authorization: 'Bearer ' + token } });
                if (res.ok) {
                    status.textContent = 'applied';
                    // Refresh details for updated total
                    const detailsList = await (await fetch('/api/categories/details?t=' + Date.now())).json();
                    const det = detailsList.find(x => x.name === categoryName);
                    if (det && typeof det.total_votes !== 'undefined') {
                        const el = document.getElementById('category-vote-count');
                        if (el) el.textContent = `ranking based on ${det.total_votes} votes`;
                    }
                } else {
                    const d = await res.json().catch(() => ({ detail: 'failed' }));
                    status.textContent = d.detail || 'failed';
                }
            } catch (e) { status.textContent = 'error'; }
        };
    }

     async function loadLeaderboard(categoryName) {
         // attach screenshot handler once
         const dlBtn = document.getElementById('download-leaderboard');
         if (dlBtn && !dlBtn._bound) {
             dlBtn._bound = true;
             dlBtn.addEventListener('click', async () => {
                 try {
                     // Use CSS media emulation by cloning node to ensure full height
                     const target = document.querySelector('.container');
                     if (!target) return;
                     const blob = await captureElementAsPng(target);
                     const a = document.createElement('a');
                     const cat = (document.getElementById('cat-name-display')?.textContent || 'leaderboard').trim().replace(/\s+/g,'_');
                     a.download = `${cat}_leaderboard.png`;
                     a.href = URL.createObjectURL(blob);
                     document.body.appendChild(a);
                     a.click();
                     setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
                 } catch (e) { console.error('screenshot failed', e); }
             });
         }

        try {
            let url = '/api/photos/leaderboard';
            if (categoryName) url = `/api/photos/leaderboard/${encodeURIComponent(categoryName)}`;
            const res = await fetch(url + '?t=' + Date.now());
            if (!res.ok) throw new Error('Failed to load leaderboard');
            const data = await res.json();
            await renderLeaderboard(data);
        } catch (e) {
            console.error('Error loading leaderboard:', e);
            const grid = document.getElementById('leaderboard-grid');
            if (grid) grid.innerHTML = '<div style="padding:20px;color:#666;">Failed to load.</div>';
        }
    }

     async function renderLeaderboard(entries) {
         // update title to include votes and question
         try {
             const questionEl = document.getElementById('category-question');
             const name = "{{ category_name or '' }}";
             let question = (questionEl?.textContent || 'Results').replace(/^Results of:\s*/, '').trim();
             let votesStr = '';
             if (name) {
                 const detailsList = await (await fetch('/api/categories/details?t=' + Date.now())).json();
                 const det = detailsList.find(x => x.name === name);
                 if (det) {
                     const count = det.total_votes || 0;
                     votesStr = `${count} votes`;
                     if (question) {
                         questionEl.textContent = `Results of: ${count} votes on ${question}`;
                     } else if (det.question) {
                         questionEl.textContent = `Results of: ${count} votes on ${det.question}`;
                     }
                 }
             }
         } catch (_) {}

        const grid = document.getElementById('leaderboard-grid');
        grid.innerHTML = '';
        if (!entries.length) {
            grid.innerHTML = '<div style="padding:20px;color:#666;">No eligible photos yet.</div>';
            return;
        }
        const categoryName = "{{ category_name or '' }}";
        const canModerate = await isModerator(categoryName);
        entries.forEach((e, idx) => {
            const div = document.createElement('div');
            div.className = 'photo-item';
            const crown = idx === 0 ? 'üëë ' : '';
            const rank = idx + 1;
            div.innerHTML = `
            <div class="stat-card">
                <img src="/api/photos/${e.filename}" alt="${e.filename}" />
                <div class="stat-label">#${rank}</div>
                <div class="stat-label">ELO: ${crown}${Math.round(e.elo_rating)}</div>
                <div class="stat-label">By: ${e.owner_username || 'unknown'}</div>
                ${canModerate ? `<div class=\"mod-actions\" style=\"margin-top:10px; display:flex; gap:8px;\">
                    <button class=\"delete-btn\" data-photo-id=\"${e.id}\">Delete</button>
                    <button class=\"set-elo-btn\" data-photo-id=\"${e.id}\" data-current-elo=\"${e.elo_rating}\">Set ELO</button>
                </div>` : ''}
            </div>
        `;
            if (canModerate) {
                const delBtn = div.querySelector('.delete-btn');
                if (delBtn) {
                    delBtn.addEventListener('click', async () => {
                        if (!confirm('Delete this photo?')) return;
                        try {
                            const token = localStorage.getItem('token');
                            if (!token) { alert('Login required'); return; }
                            const catName = categoryName;
                            const catSel = await (await fetch('/api/categories/select-by-name/' + encodeURIComponent(catName), { method: 'POST', credentials: 'include' })).json();
                            const res = await fetch(`/api/photos/categories/${catSel.category_id}/photos/${e.id}`, {
                                method: 'DELETE',
                                headers: { Authorization: 'Bearer ' + token }
                            });
                            if (res.ok) { div.remove(); }
                            else { const d = await res.json().catch(() => ({ detail: 'Failed' })); alert(d.detail || 'Failed to delete'); }
                        } catch (err) { alert('Error deleting'); }
                    });
                }
                const setBtn = div.querySelector('.set-elo-btn');
                if (setBtn) {
                    setBtn.addEventListener('click', async () => {
                        const token = localStorage.getItem('token');
                        if (!token) { alert('Login required'); return; }
                        const current = Number(setBtn.getAttribute('data-current-elo')) || 1200;
                        const input = prompt('Set new ELO (1 - 3999):', Math.round(current));
                        if (input === null) return;
                        const value = Number(input);
                        if (!isFinite(value) || value <= 0 || value >= 4000) { alert('Invalid ELO'); return; }
                        try {
                            const res = await fetch(`/api/photos/${e.id}/elo?elo=${encodeURIComponent(value)}`, {
                                method: 'PATCH',
                                headers: { Authorization: 'Bearer ' + token }
                            });
                            if (res.ok) {
                                // refresh just this card's displayed rating
                                const meta = div.querySelector('.meta span');
                                if (meta) { meta.textContent = meta.textContent.replace(/^[^\d]*/, '').replace(/\d+/, String(Math.round(value))); }
                            } else {
                                const d = await res.json().catch(() => ({ detail: 'Failed' }));
                                alert(d.detail || 'Failed to set ELO');
                            }
                        } catch (err) { alert('Error setting ELO'); }
                    });
                }
            }
            grid.appendChild(div);
        });
    }
     // helper to capture element as PNG using built-in canvas drawImage on SVG foreignObject
     async function captureElementAsPng(el) {
         const rect = el.getBoundingClientRect();
         const width = Math.ceil(rect.width);
         const height = Math.ceil(el.scrollHeight || rect.height);
         const svg = new Blob([
             `<?xml version="1.0" standalone="no"?>\n`+
             `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">`+
             `<foreignObject width=\"100%\" height=\"100%\">`+
             new XMLSerializer().serializeToString(el.cloneNode(true))+
             `</foreignObject></svg>`
         ], { type: 'image/svg+xml;charset=utf-8' });
         const url = URL.createObjectURL(svg);
         const img = new Image();
         img.crossOrigin = 'anonymous';
         await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
         const canvas = document.createElement('canvas');
         canvas.width = width; canvas.height = height;
         const ctx = canvas.getContext('2d');
         ctx.fillStyle = getComputedStyle(document.body).backgroundColor || '#fff';
         ctx.fillRect(0,0,width,height);
         ctx.drawImage(img, 0, 0);
         URL.revokeObjectURL(url);
         const blob = await new Promise(r => canvas.toBlob(r, 'image/png', 1));
         return blob;
     }
 </script>
 {% endblock %}